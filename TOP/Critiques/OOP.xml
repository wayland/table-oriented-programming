<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../interface/layout.xsl"?>
<page>
<filename>Critiques/OOP.xml</filename>
<sitedir>TOP</sitedir>
<content>
<p>Tablizer/TOPMind has put a lot of effort into criticing things that he 
thought should be table-oriented programming but weren't.  I'm going to  work 
through some of his critiques, and try to divide them into those that aren't 
useful and those that are.  </p>

<h1>History</h1>

<p>Before jumping into his critique, it's useful to look at the defeat of the 
Procedural Programming Paradigm (despite its euphoniousness) by the OOP 
paradigm.  As part of this change in the software industry, OOP made many claims 
vs. Procedural.  As rightly pointed out by Tablizer/TOPMind, many of those 
critiques didn't apply to table-oriented programming, but I would argue that TOP 
was <i>not</i> procedural, but instead its own paradigm.  </p>

<h1>Counter-Productive Thoughts by Tablizer/TOPMind</h1>

<p>In my opinion, the following are mistakes made by Tablizer/TOPMind that have 
prevented work towards the unification of OOP and TOP.</p>

<ul>
	<li><b>Uni-paradigm thinking:</b> He assumed that a language couldn't allow 
		<i>both</i> OOP and TOP.  This followed from the belief that he shared 
		with the OOP camp, that there should be one encompassing paradigm, and 
		everything should be pushed into it.  </li>
	<li><b>Confusing TOP and Procedural:</b> As I said above, I would argue that 
		TOP was <i>not</i> procedural, but instead its own paradigm.  </li>
	<li><b>Assuming Nouns and Verbs Equal:</b> According to 
		<a href="https://wordnet.princeton.edu/documentation/20-wnstats7wn">
		2.0 wnstats(7WN)</a> (WordNet stats), there are 114,686 unique nouns in 
		English, whereas there are only 11,306 unique verbs.  This means 
		that:
	<ul>
		<li>Most humans think in nouns more than in verbs</li>
		<li>Relatedly, managing the multiplicity of nouns is probably more 
			important than managing the mulitplicity of verbs</li>
	</ul>
		However, that doesn't mean that verbs are unimportant.  It just means 
		that primary importance is rightly given to nouns
	</li>
</ul>

<h1>OOP Myths Categorised</h1>

<p>One of the things that Tablizer/TOPMind was right about is that many 
criticisms (by both sides) are, 
<a href="https://web.archive.org/web/20121109132437/http://www.geocities.com/tablizer/science.htm">
in his own words</a> unprovable.  </p>

<p>He made a list of OOP myths.  Some are more relevant than others.  </p>

<h3>Categorisation System</h3>

<p>Based on this, I've come up with the following categorisation system for his myths:</p>

<ul>
	<li><b>Useful:</b> Criticisms that are useful; in this, I'm <i>including</i> 
		ones based on the relative importance of nouns and verbs.  While the OOP 
		people were correct here, TOP thinking allows us to increase the 
		importance of verbs to a secondary position, rather than being eg. equal 
		with adjectives</li>
	<li><b>Dated:</b> Criticisms that were relevant at the time, but are no 
		longer, divided into:</li>
	<ul>
		<li>Those disproved by years of usage (about as good proof as we get for 
			software design)</li>
	</ul>
	<li><b>Not Relevant: </b> Criticisms that were never relevant, divided 
		into:</li>
	<ul>
		<li>Not relevant because of the above-mentioned TOP/Procedural 
			confusion</li>
		<li>Not relevant due to being difficult to measure</li>
	</ul>
</ul>

<h3>The Myths</h3>

<ul>
	<li><b>Useful</b></li>
	<ul>
		<li> <span class="smallquote">Myth: Most things fit nicely into hierarchical taxonomies</span></li>
		<li> <span class="smallquote">Myth: Most operations have one natural "primary noun"</span></li>
		<li> <span class="smallquote">Myth: OOP better hides persistence mechanisms</span></li>
		<li> <span class="smallquote">Myth: Only OOP offers automatic initialization</span></li>
		<li> <span class="smallquote">Myth: Implementation changes significantly more often than interfaces</span></li>
		<li> <span class="smallquote">Myth: OOP models human thought better (Which human?)</span>  
			A better question to ask: on what topic?</li>
		<li> <span class="smallquote">Myth: OOP better models spoken language</span> 
			Probably only true for languages with an
			<a href="https://en.wikipedia.org/wiki/Object%E2%80%93verb_word_order">OV</a> 
			<a href="https://en.wikipedia.org/wiki/Object%E2%80%93verb_word_order">
			Word Order</a>.  English doesn't (we use 
			<a href="https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object_word_order">
			SVO</a>).  </li>
		<li><i>DBMS-related</i></li>
		<ul>
			<li> <span class="smallquote">Myth: OO databases can better store large, 
				multimedia data</span>.  This is the SQL vs NoSQL debate.  </li>
			<li> <span class="smallquote">Myth: OODBMS are overall faster than 
				RDBMS</span>.  I'm not sure here.  </li>
			<li> <span class="smallquote">Myth: SQL is the best relational 
				language</span>.  TOP will work better if we get a modern TOP 
				language.  </li>
		</ul>
		<li><i>Noun-grouping related</i></li>
		<ul>
			<li> <span class="smallquote">Myth: Self-handling nouns are more useful than 
				self-handling verbs</span>.  Probably not a myth (mostly -- 
				there are exceptions); in English, there are many more nouns 
				than verbs. </li>
			<li> <span class="smallquote">Myth: OOP manages behavior better</span> [whose behaviour?]</li>
		</ul>
	</ul>
	<li><b>Dated</b></li>
	<ul>
		<li><i>Disproved by years of usage</i></li>
		<ul>
			<li> <span class="smallquote">Myth: OOP is a proven general-purpose technique</span></li>
			<li> <span class="smallquote">Myth: Most programmers prefer OOP</span></li>
		</ul>
		<li><i>Was once true, no longer</i> (because OOP developed)</li>
		<ul>
			<li> <span class="smallquote">Myth: OOP eliminates the "complexity" of 
				"case" or "switch" statements</span>.  It's not the only way to 
				do it, but it does.  </li>
			<li> <span class="smallquote">Myth: Sub-typing is a stable way to model 
				differences</span>.  This was true until roles came along.</li>
		</ul>
		<li> <span class="smallquote">Myth: OOP would have prevented more Y2K 
			problems</span>.  This one's wrong enough to need an explanation.  
			The Y2K problems were caused by storage being expensive, and 
			programmers only using 2-digit dates.  Any structured paradigm (such 
			as TOP or OOP) would have made it easier to fix, but many of these 
			programs were in languages older than structured paradigms (eg. 
			COBOL).  So while it's technically true, it's about as useful as 
			saying "Caesar would've lived longer if he'd had a machine gun".  
			</li>
	</ul>
	<li><b>Not Relevant</b></li>
	<ul>
		<li><i>Procedural vs. TOP confusion</i></li>
		<ul>
		  <li> <span class="smallquote">Myth: C and Pascal are the best procedural can get</span></li>
			<li> <span class="smallquote">Myth: Procedural cannot do components well</span> </li>
			<li> <span class="smallquote">Myth: OOP models the real world better</span></li>
			<li> <span class="smallquote">Myth: OOP makes programming easier and faster</span></li>
			<li> <span class="smallquote">Myth: OOP increases reuse (recycling of code)</span></li>
			<li> <span class="smallquote">Myth: OOP reduces the number of places that require changing</span></li>
			<li> <span class="smallquote">Myth: OOP does automatic garbage-collection better</span> [this is an implementation detail from my POV]</li>
		</ul>
		<li><i>Difficult to measure</i></li>
		<ul>
			<li> <span class="smallquote">Myth: OOP makes programming more visual</span></li>
			<li> <span class="smallquote">Myth: OOP "does patterns" better</span></li>
			<li> <span class="smallquote">Myth: Only OOP can "protect data"</span></li>
			<li> <span class="smallquote">Myth: Procedural/Relational ties field types and sizes to the code more</span></li>
			<li> <span class="smallquote">Myth: Procedural/Relational programs cannot "factor" as well</span></li>
			<li> <span class="smallquote">Myth: OOP is more "modular"</span></li>
			<li> <span class="smallquote">Myth: OOP divides up work better</span></li>
			<li> <span class="smallquote">Myth: OOP "hides complexity" better</span></li>
			<li> <span class="smallquote">Myth: OOP is "better abstraction"</span></li>
			<li> <span class="smallquote">Myth: OOP reduces "coupling"</span></li>
			<li> <span class="smallquote">Myth: OOP does multi-tasking better</span>. 
				Dataflow is the best programming style for this.  Dataflow (like 
				OOP and TOP) can theoretically be done in any language, but 
				useful are tools that enable it, such as <a href="RAD/Code-Editors.html#Dataflow">
				Dataflow Code Editors</a>.</li>
			<li> <span class="smallquote">Myth: OOP scales better</span></li>
			<li> <span class="smallquote">Myth: OOP is more "event driven"</span></li>
		</ul>
		<li><i>Not sure what he means</i></li>
		<ul>
			<li> <span class="smallquote">Myth: Procedural cannot extend compiled portions very well</span> [what does this even mean]</li>
			<li> <span class="smallquote">Myth: No procedural language can re-compile at the routine level</span></li>
		</ul>
	</ul>
</ul>

<p>That probably doesn't cover all of his objections to OOP, but it probably covers the major ones.</p>

<h3>OOP and the Language Analogy</h3>

<ul>
	<li>Noun: Object :: Variable</li>
	<li>Adjective: property/attribute :: related variable</li>
	<li>Verb: Method :: function</li>
	<li>Adverb: method parameter :: function parameter (or maybe, in both 
		cases, the default parameter)</li>
	<li>Pronoun: topic variable $_ (given/with/foreach)</li>
	<li>Preposition: ???</li>
	<li>Conjunction: boolean operators</li>
	<li>Interjection: ???</li>
</ul>

<p>cf. https://www.quora.com/How-many-parts-of-speech-are-covered-in-English-8-or-9</p>
</content>
</page>
