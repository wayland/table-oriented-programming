<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../interface/layout.xsl"?>
<page>
<filename>History-of-Programming.xml</filename>
<sitedir>Other-Items</sitedir>
<content>

<div class="blockquote">
The thing that hath been, it is that which shall be; 
and that which is done is that which shall be done: 
and there is no new thing under the sun.
<div class="reference">
  <i><a href="https://www.biblegateway.com/passage/?search=Ecclesiastes+1&amp;version=KJV#en-KJV-17325">
  Ecclesiasties 1:9</a>, King James authorised translation of the Bible, 
  translated 1611 (revised 1769), from the Hebrew manuscript, originating around 900BC</i>
</div>

</div>

<p>This is a fairly focussed history of programming.  Its purposes are:</p>
<ul>
  <li>To help people distinguish OOP from Agent-Oriented Programming, which 
    has often been called OOP as well, but is really a somewhat separate 
    paradigm</li>
  <li>To help people see the reinvention of old ideas under new names</li>
</ul>

<p>In some of the eras below, people often thought they had invented a new
thing, when really they were just reinventing something older.  </p>

<style>
td {
  vertical-align: top;
}
td h4 {
  margin-top: 0;
}
</style>

<table>
  <tr>
    <th>Era</th>
    <th>Years</th>
    <th>Object-Oriented Programming</th>
    <th>Agent-oriented Programming</th>
    <th>Table-Oriented Programming</th>
  </tr>
  <tr>
    <th>Definition</th>
    <td></td>
    <td>The Imperative-style OOP that is mostly used in modern-day languages</td>
    <td>aka Message-passing OOP; see 
      <a href="http://stereobooster.github.io/two-big-schools-of-object-oriented-programming">
      Two big schools of Object-Oriented Programming</a> for details</td>
    <td></td>
  </tr>
  <tr>
    <th>Mainframe Era</th>
    <td>1960s-1980</td>
    <td colspan="2">
      <h4>The Common Era</h4>
      <p>In 1963, Ivan Sutherland's <a href="https://en.wikipedia.org/wiki/Sketchpad">
        Sketchpad</a> was effectively the earliest object-oriented program, 
        though its use of terminology isn't what we'd expect today.  However, 
        it wasn't written in an object-oriented language.  </p>
        
      <p>Object-Oriented Programming began in 1967 with the creation of Simula
      by Ole-Johan Dahl and Kristen Nygaard.  This introduced classes, objects, 
      inheritance, and polymorphism, and also the Actor model (cf. 
      <a href="https://en.wikipedia.org/wiki/History_of_the_Actor_model">
      History of the Actor model</a>).  </p>

      <p>Alan Kay's Smalltalk in 1972 was considered widely influential in
        Object-oriented circles, and continued the use of the Actor Model.</p>
    </td>
    <td>
      <h4>Decision Table Programming</h4>

      <p>The earliest iteration I found of table-oriented programming is the paper
      <a href="https://www.rand.org/content/dam/rand/pubs/papers/2006/P2608-1.pdf">
      What is DETAB-X?</a> published by Solomon L. Pollack in October 1962.  It 
      details DETAB, a table-oriented variant of COBOL.  </p>

      <p>This led to languages such as <a href="https://en.wikipedia.org/wiki/Filetab">
      Filetab</a> in the late 60s, whose descendents continued in the 70s and 80s,
      and a Linux version was even released in 2001.  The company owning Filetab
      was liquidated in 2010.  </p>

      <p>This early iteration is often labelled 
      <a href="https://en.wikipedia.org/wiki/Decision_table">Decision Table</a>
      programming.  </p>
    </td>
  </tr>
  <tr>
    <th>PC Era</th>
    <td>1980-1995</td>
    <td>It was during this era that Object-Oriented Programming came into the 
      mainstream.  This had two effects; the first was that 
      it brought larger encapsulation to the mainstream, replacing to a 
      certain extent the old Procedural methodology.  The second was that this
      also resulted in dropping the Actor model and message passing, not 
      because there was anything inherently wrong with them, but because they
      weren't suited to the minds of those strongly influenced by procedural
      (or, for that matter, functional) programming.  This was the era of CLOS
      and C++.  </td>
    <td>During this era, message-passing OOP was somewhat sidelined by
      imperative-style OOP.  However, this was also the era in which the early 
      work on <a href="https://en.wikipedia.org/wiki/Agent-oriented_programming">
      Agent-Oriented Programming</a> was done.  </td>
    <td>
      <h4>Data-Oriented Programming</h4>

      <p>The Term "Data-oriented Programming" has been used in various ways around
      the web, but the one we're using here is the one on Wikipedia about
      <a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Data-oriented_languages">
      Data-oriented languages</a>.  These seem to be divided into table and tree
      types, but the common theme is a close integration with a database, rather 
      than keeping it at arm's length as SQL-using systems do (but PL/SQL, or even 
      SQL, would be an example of Data-oriented Programming).  </p>

      <p>Popularity of the table branch of data-oriented programming surged in the 
      80s with the use of languages like:</p>

      <ul>
        <li>dBase</li>
        <li>Clipper</li>
        <li>Harbour/xHarbour (Open Source)</li>
        <li>Visual FoxPro/Microsoft FoxPro</li>
      </ul>

      <p>These languages had useful features that are not seen in modern programming 
      languages, primarily the tight integration of database features into the 
      language.  </p>
    </td>
  </tr>
  <tr>
    <th>Web 1.0 Era</th>
    <td>1995-2008</td>
    <td><h4>Take over the world</h4>
      This was the era in which Imperative OOP took over the world.  While 
      the model of OOP wasn't necessarily agreed on, most languages incorporated
      a lot more OOP than previously.  </td>
    <td>While some variants of agent-
      oriented programming lean more towards logic programming (eg. 
      <a href="https://en.wikipedia.org/wiki/GOAL_agent_programming_language">
      GOAL</a>, others are definitely in line with the Actor Model (eg. 
      <a href="https://en.wikipedia.org/wiki/SARL_(programming_language)">
      SARL</a>.  </td>
    <td>
      <h4>Table-Oriented Programming</h4>

      <p>With the advent of the internet, and the popularity of Object-Oriented 
      Programming, these languages fell out of use.  </p>

      <p>In 1998-2002, as the table-oriented languages were falling out of use, 
      Tablizer/TOPMind (aka Tablizer/TOPMind) wrote a series of articles 
      on "Table-Oriented Programming" (TOP).  These were, in their own words, 
      unstructured and piecemeal.  These advocated for various features prevalent in 
      these languages, and a few ideas of their own.  </p>

      <p>Unfortunately, at the time, TOP was seen (especially by the biggest TOP 
      advocate, Tablizer/TOPMind/TOPMind) as a competitor to OOP.  This meant he spent a lot 
      of time criticising the OOP community (often validly) for the weaknesses of OOP 
      (and OOP was weak before modern ideas such as the invention of roles).  </p>

      <p>This led to a situation where the vast majority of people followed the OOP 
      camp, without considering a multi-paradigm approach.  Had more effort been put 
      into integrating TOP into modern programming languages, everyone's lives 
      would've been a lot easier (or at least most programmers).  </p>
    </td>
  </tr>
  <tr>
    <th>Web 2.0 Era</th>
    <td>2008-2022</td>
    <td>This was a time of steadily increasing object orientation in some of 
      the less structured languages.  </td>
    <td></td>
    <td>
      <h4>The Interregnum</h4>

      <p>As a part of the interregnum, Table-Oriented Programming was pushed 
        into the database, but then the common methodology was that code was 
        moved out of the database, mainly for efficiency/scalability reasons 
        (though the Smart DB/Thick DB people argue that this was often just 
        a case of bad programmers).  This meant that it was no longer easy
        to put code in the tables.  </p>
    </td>
  </tr>
  <tr>
    <th>AI Era</th>
    <td>2022+</td>
    <td></td>
    <td>Look what's going to flourish!  There are now many agent-based systems,
      though few have a genuine agent-based programming language to go with 
      them.  </td>
    <td>
      <h4>Rebirth</h4>

      <p>This site is an attempt to make use of the good parts of TOP while hopefully 
      leaving behind the oppositional nature of previous discourse on the topic; 
      there may still be some pointing out of the weaknesses of various technologies, 
      but only with the intent of showing the power of multi-paradigm programming, not 
      with the intent of making anyone abandon the named technologies.</p>

      <p>I will consider this a success if more languages adopt table-oriented 
      programming as one of their available paradigms.  </p>
    </td>
  </tr>
</table>

<p>As a side note, there's some similarity between Agent-Oriented Programming 
and Dataflow programming, but Dataflow programming is more aimed at a 
continuous flow of data through a few main streams, rather than message 
passing.  While the concepts are similar, the mindsets are different.  </p>

<p>It can also be seen by examining the history of programming that a lot of
effort has been expended simply trying to drag programmers further away from
the procedural model and C.  C++ was the inclusion of OOP in C, but only the Classes
part, not the Actor Model part.  Perl was the inclusion of some Functional 
features in a C-like language; its successors (Ruby, Python, PHP) were usually 
less functional-aligned.  </p>

</content>
</page>