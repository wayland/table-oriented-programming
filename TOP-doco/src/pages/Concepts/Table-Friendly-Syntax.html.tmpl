<div class="title">Table-Friendly Syntax</div>

<h1>Tables as First-Class Citizens</h1>

<h3>Field Groups</h3>

<div class="blockquote">

One of the most time-wasting process in programming table processing with 
many of the popular languages is having to type the names of all the fields that 
will show up on a screen or report. It would be much easier to specify the name 
of a set, and all fields belonging to that set would then be used. Although sets 
could be pnumonic names, we chose to use letters in our example for 
simplicity.

<p>Suppose that we had to make a report that showed customer transaction detail, 
but which ommited customer names for reasons of confidentiality. With our setup, 
we could just ask for a report on all fields in set "B" (See the Groups column 
above).  When dealing with tables with 50 plus fields, specifying a set name is 
much simpler than typing 50 names or building a field loop.</p>

<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Miscellanous Table Features</h3>

<div class="blockquote">
<ul>
	<li>Because tables may come from many different sources, TOP should provide 
		a way to query to see which features are available. For example, there 
		should be a way to query a table source to see if the query limit 
		feature (FIX: described above) is available on a given table.</li>
	<li>ITOP should be able to generate temporary tables that automaticaly last 
		only as long as the program is running or until explicitly closed. These 
		tables should have a unique identity (automatically generated) to avoid 
		multi-user conflicts.</li>
	<li>Easy way to make a memory or temporary version or copy of a record, and 
		then be able to load this to and from a multi-record table when 
		needed.</li>
	<li>TOP should have the ability to evaluate internal-aware expression 
		strings, similar to the Perl EVAL() function (xbase uses "&amp;").  This 
		allows expressions with internal syntax and function calls (not just 
		SQL) to be stored in tables. This is a very powerful language feature. 
		Note that this is not the same as a general-purpose expression evaluator 
		because we often need a way to call <b>internal</b> functions. (A way to 
		test the validity of the expression should also be provided).</li>
</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h1>Views as First-Class Citizens</h1>

<div class="blockquote">
<ul>
	<li>Ability to temporarily "join" several tables into one virtual table and 
		perform operations on it as if it were an actual table. Sometimes these 
		are called "views".  This provides similar functionality as inherited 
		properties in OOP.</li>
</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h1>Built-in Forms</h1>

<div class="blockquote">
<ul>
<li>The acceptance of the scrolling screens of browsers should hopefully reduce 
the desire to jam as many fields on screen as possible. This will make it easier 
for the ITOP system to generate input screens based on the DD alone. Almost 
everything needed to generate such screens could come from the DD and the 
validation functions. graphic input screen builders should become a thing of the 
past.</li>

<li>Built-in, but optional, sort and search features for data grids. The user 
should be able to double-click on a column heading and chose to sort by or 
search on the field of that column.</li>

<li>Use of checkboxes, icons, etc. as representations of fields should be 
definable in the DD. Perhaps this can be done by having the post-validation 
function return a string with a special code for GUI components. For example, a 
checkbox might be specified with "@gui:checkbox value=on". An icon could be 
represented as such: "@gui:icon file='folder.gif'".</li>

</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>


<h1>Built-in Reports</h1>

<h1>Miscellaneous Implementation Features</h1>

<div class="blockquote">
<ul>
	<li><b>General</b></li>
	<ul>
	<li>Automatic control of data buffering during input and changes. The 
		programmer should be able to simply specify whether "optimistic" or 
		"pessimistic" record locking occurs, for example. He or she should not 
		have to create buffer variables and so forth.</li> 
	<li>A way to limit the upper size or time of a query result. Users 
		generating "runaway" queries is a common cause of performance 
		bottlenecks.</li>
	<li>Lists and array-like structures that can expand beyond memory space. 
		(The language automatically creates and handles temporary file buffering 
		if needed).  This is a contrast to constructs like Java VECTORs that 
		have a limit in size and quantity (related to memory constraints).</li> 
	</ul>
	<li><b>Data Dictionary</b></li>
	<ul>
	<li>Be able to create memory variables that take on characteristics of a 
		field as specified in the DD. In addition, fields should be "castable" 
		to other DD types if needed.</li>
	</ul>
	<li><b>Control Tables</b></li>
	<ul>
	<li>All <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/cntrl1.htm">
		control tables</a>, such as the DD's, should be 
		regular tables that can be processed just like any data table. 
		Encryption or some other technology can be used to protect such tables 
		from direct access by users if needed.</li>
	</ul>
</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h1>Miscellaneous other features</h1>

<div class="blockquote">

<h4>Access Modes</h4>
<span style="color:red">TODO: What about cursors?</span>
Have 2 access modes: "direct" and "transactional". Direct access
mode allows one to access a field as if it was a memory variable,
and know that any changes will be written into the field. Transactional
mode is a bit more formal; you have to explicitly issue a Save
operation to save the record. Note that Direct Access mode may still
buffer actual writes to improve I/O, but the programmer need
not worry about this. Here is an example of each:
<pre>
   t = DBopen("tableA"  #<b>direct</b>)   // open table or view
   seek t #where name = 'Fred'
   if found(t) {
      t.name = 'Bob'    // change name from Fred to Bob
   }
   close t
   // '#' mark named parameters

Transactional:

   t = DBopen("tableA"  #<b>transact</b>)
   seek t #where name = 'Fred'
   if found(t) {
      t.name = 'Bob'
      if not save(t) {   // needed or no save is done
        // handle error
      }
   }
   close t     // (may not be necessary in some langs)
</pre>
The direct approach can be used if you know there will not
be resource conflict issues with other users or processes,
such as if you have exclusive access to the table. Note
that although this example can be easily done with SQL,
more interactive behavior would require more steps in SQL.
Example:
<pre>
   t = DBopen("tableA" #direct)   // open table or view
   seek t #where name = 'Fred'
   if found(t) {
      t.name = 'Bob'    // change name from Fred to Bob
   } else {
      display "Error, Fred not found."
   }
   close t 
</pre>
SQL would require one query to request the change, and another
to verify the change. Either that, one qurey to see if the
target is there, and another to change it.
<pre>
  s = "select from tableA where name = 'Fred' "
  t = DBopen(#sql s)
  if found(t) {
     s2 = "update tableA set name = 'Bob' "
     DBexecute  s2
  } else {
     display "Error, Fred not found."
  }
</pre>     

In this case it is not that much more code, but
in many situations it gets cluttered. Direct SQL makes it
tougher to mix reads and writes, usually requiring the issuing
of new queries. (Perhaps the direct approach could be
implemented via SQL underneath, but not something the
programmer has to concern him/herself with.)

<p>
Note that <tt>recCnt(t) &gt; 0</tt> could replace <tt>found(t)</tt>
where <tt>recCnt</tt> is short for "Record Count". This example
assumes there is only one Fred.

<div align="center">
See Also: <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/sqlcrit.htm">SQL Critique</a>
</div>

<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>
