<p>If you're a developer, wouldn't you like to get more done?  And if you're a 
manager, wouldn't you like your developers to be more productive?</p>

<p>I would argue that in the 90s, individual developer productivity was higher 
than it is now.  Our goal here is to understand:</p>
<ol>
	<li>Why it was higher</li>
	<li>The (good) reasons it went downhill</li>
	<li>What we can learn to improve productivity</li>
</ol>

<h1>Why was it higher?</h1>

<p>The short version is that there was more productivity-oriented tooling; but 
exactly what was it?</p>

<h3>RAD IDEs</h3>

<p><i>Rapid Application Development - Integrated Development 
Environments</i></p>

<p>In the 90s, programming languages weren't just languages; they were entire 
toolsuites.  There were two most dominant general-purpose languages, C(++) and 
Pascal.  Each had its own tool suite.  </p>

<p>The example I'm most familiar with is Delphi.  This was made by Borland, and 
is a descendent of Turbo Pascal (if anyone is interested, there's an Open 
Source version called <a href="https://www.lazarus-ide.org/">Lazarus</a>).  </p>

<p>The big advantage here was that it allowed one to drag and drop components 
onto forms (or reports), edit the properties, attach them to databases, and 
then it created the backend code to make it all happen.  Want to know what 
happens when you click a button?  In the GUI editor, go to the Events tab, 
click the onClick event, and the code will appear in the code editor.  </p>

<p>These were not the only languages with an attached and integrated tool suite; 
MS Access is a classic example of one that's still like this.</p>

<h3>Domain-Specific Languages</h3>

<p>These were languages that specialised in particular areas.  There were a 
number that specialised in databases/tables; amongst these were SQL and the 
xBase family of languages, the second of these being one of the main 
inspirations behind TOP.  These languages had their drawbacks, but they were 
usually particularly good in the areas they specialised in.  </p>

<h1>Why Did it Go Downhill?</h1>

<p>From about 1995-2005, there was a lot of change happening.  </p>

<h3>Fragmentation</h3>

<h4>Fragmentation of Programming Languages</h4>

<p>From there being only a few languages, there was a great proliferation of 
languages; Javascript, Perl, PHP, Python, Ruby, and other scripting languages 
hit their stride around this point.  Competing more directly with C/Pascal, we 
had Java and C#.  </p>

<p>This meant that each language community put the majority of their effort into 
the language, and less into the tooling.  When there *were* efforts towards 
tooling, they were often multi-language, meaning that more languages got 
covered, but at the expense of other IDE features.  </p>

<p>Open Source got a big boost during this era too.  With so many langauges 
being available for free, people also, in my opinion, became less willing to pay 
for both languages, and IDEs that would make them more productive.  </p>

<p>Was this good?  Yes, we got some great programming languages out of it, and 
got people to rely less on C.  Was it worth it?  Yes.  </p>

<h4>Fragmentation of GUIs</h4>

<p>In the early 90s, each OS generally had one GUI, and that was what you 
developed for.  The primary GUIs were MacOS and Windows, with XWindows (Unix) 
also being in the mix.  </p>

<p>Then came the Web.  The web was not well-designed to be 
a GUI (especially in the early days), but that didn't stop people trying.  None 
of the GUI design tools worked for making web interfaces.  </p>

<p>Was this good?  Yes, because now when people wanted to use a program, they 
could just go to a website, instead of having to have a box with some disks and 
a manual mailed to them (or they'd have to go to the store to get it).  Was it 
worth it?  I'd say yes.  </p>

<h3>Scaling</h3>

<p>Programs changed from the days when most PC programs were made by developers 
sitting at home coding.  Suddenly there were issues of scale (which had been 
faced before, but often on corporate servers, rather than PCs).  </p>

<h4>Scaling of Concurrent Users</h4>

<p>With the advent of the web in 1995, suddenly many more programs were being 
run on centralised servers.  On the plus side, people didn't have to distribute 
their software any more; it was nicely there on the server.  On the minus side, 
this meant that programmers were suddenly having to worry about scaling their 
programs to multiple simultaneous users on the same computer.  </p>

<p>Was it a good idea?  Yes, because of all the things we can do with the 
Internet.  Was it worth it?  Yes.  </p>

<h4>Scaling of Developers</h4>

<p>Instead of a single person working on a program, there were now multiple 
people working on programs.  Source control programs existed (eg. RCS, SVN), but 
with the release of git in 2005, we finally had an Open Source solution for 
source control that was powerful and actually worked.  </p>

<p>Having multiple people working on a program introduces some overheads.  
Wanting to keep the production environment running while testing in a shared 
area introduces more overheads.  Think about the amount of time it takes you to 
make an one-line (or one-character) change on your local, vs. the amount of time 
it takes to commit it to development, staging and production in a useful 
way.</p>

<p>Was this a good idea?  Yes, because now multiple developers can work 
together, and websites are less likely to go down.  Was it worth it?  Yes.  </p>

<h4>Scaling of Development Teams</h4>

<p>With the scaling of the team, UI designers were introduced.  This was 
definitely a good thing, but generally meant that there was one more person who 
had to be involved in the GUI design; it was no longer enough to drop some 
components on a form and call it done.  In some cases, the design tools weren't 
even fully accessible to the developers unless extra licenses were bought.  </p>

<h3>Inflexible Languages</h3>

<p>Many drawbacks to OOP have been pointed out over the years, and various OOP 
modifications have been made to overcome them (eg. roles, aspect-oriented 
programming, and the like).  A full-orbed OOP system is useful, but a poor 
one has its own scaling limits just like non-OOP programming does.  </p>

<p>Just as the "everything is a function languages" (like early PHP) found it 
more productive to add the object-oriented paradigm, so the "everything is an 
object (and only an object)" people were hampering their developers.  Unlike the 
other items in this list, this one is currently alleviated by the mere existence 
of multi-paradigm langauges (but how to get people to use them?)  </p>

<h3>Downhill Summary</h3>

<p>Were the things above worth it?  Yes.  Did the things above make our lives 
harder by reducing the available tooling?  Also yes.  What can we do about it?  
Read on!  </p>

<h1>How Can we Improve Productivity?</h1>

<div class="blockquote">

<p>Much that once was is lost, for none now live who remember it.  ... And some 
things that should not have been forgotten were lost. History became legend. 
Legend became myth. And for two and a half thousand years, the Ring passed out 
of all knowledge.  </p>

<div class="reference" style="display: flex">
<div style="display: inline-table">Galadriel (voiceover), <i>The Fellowship of 
the Ring</i> movie, Peter Jackson, Fran Walsh, and Philippa Boyens</div>
</div>
</div>


<p>There are still things we can learn from RAD IDEs and DSLs.</p>

<h3>What can we learn from Domain-Specific Languages?</h3>

<p>Before delving into DSLs, I'd like to make a very brief visit to:</p>

<h4>Multi-paradigm Programming</h4>

<p>Each programming paradigm is a tool in your toolbox.  The more paradigms a 
programming language allows for, the more tools you have in your toolbox.  
Each paradigm not available is one less tool in your toolbox.  </p>

<p>With this in mind, the best way to get the benefits of a DSL in the modern 
era is not to use the DSL, but to integrate the paradigm of the DSL into a 
language which is already multi-paradigm.  My personal preference is Raku (see 
<a href="Other-Items/Paradigm-Comparisons.html">Paradigm Comparisons</a> for 
more information).</p>

<h4>Learning from DSLs</h4>

<p>No doubt there are many things we can learn from DSLs, but I'm not familiar 
enough with most of them to derive the lessons here.  I can highlight only one 
particular one we can learn from (that's not a markup language), and that is 
<b>Table-Oriented Programming</b>.  In the 1995-2005 era, Table-Oriented 
Programming (TOP) was argued to be an alternative all-encompassing paradigm to 
OOP.  Neither won this argument, but OOP was accepted in large part ("everything 
is an object, but maybe not <i>just</i> and object"), whereas TOP, to the extend 
it was used at all, was left to SQL and spreadsheets.  But the lessons that TOP 
has can be applied in a multi-paradigm setting without disrupting the other 
paradigms, and will improve our data handling.</p>

<h3>What can we learn from RAD IDEs?</h3>

<p>The lesson here is easier for me to identify, probably because I've spent 
more time over the years using various RAD IDEs.  The big lesson is, in many 
cases, visual editors of various sorts make people more productive.  I think I 
can best express this by making a bullet list of the things that I think should 
be implemented in an IDE that fully supports Programming Productivity:</p>

<ul>
	<li><b>Code Editors</b></li>
	<ul>
		<li><i>Regular code editors:</i> These are standard; no explanation 
			needed</li>
		<li><i>Source control visual tools:</i> To reduce the time spent managing 
			the code</li>
		<li><i>Tablish Code Editors:</i> In Table-Oriented Programming, both 
			code and data can be stored in tables.  There should be a visual 
			editor for the tables in question, though it should have a way of 
			editing the cell in a separate window (so we can have the table on 
			one screen, and the code for a particular cell on another).  Think 
			of this as being like a spreadsheet, but you can compile it).</li>
		<li><i>Dataflow Code Editors:</i> In dataflow programming (such as 
			node-red or n8n, but also any language that has concurrency 
			features), there's a diagram that represents how the data flows.  
			Some of the nodes in the diagram have code inside them.  In my 
			experience, the best interface is that of n8n, which stores the 
			dataflow from previous runs, and, when a code node is clicked, it 
			shows you the code in the centre, on the left the data from the 
			previous run, and on the right, what your current code would turn 
			that data into.  n8n only really handles json though.  </li>
	</ul>
	<li><b>GUI Editor:</b> Something that allows editing the GUI in a visual, 
		drag-and-drop manner (Forms)</li>
	<li><b>Document Editor:</b> This allows people to edit a document that could 
		be made into a report.  This would be influenced by word processors, 
		and by the Notebook model (cf. Jupyter)</li>
</ul>

<hr/>

	<li><b>User interface Markup:</b> Many <a href="https://en.wikipedia.org/wiki/User_interface_markup_language">
		user interface markup languages</a> have been proposed.  The current 
		winner is HTML, which is not what HTML was designed for.  The linked 
		Wikipedia page doesn't even mention XForms.  If an XML-based on were 
		implemented using the technique at 
<a href="https://stackoverflow.com/questions/42073103/for-what-reason-browser-side-xslt-is-not-widely-used-by-web-developers">
		For what reason browser side XSLT is not widely used by 
		web-developers?</a>, this would make it easier to separate design and 
		development tools.  The UI markup language could be produced by RAD 
tools, and 
</li>
