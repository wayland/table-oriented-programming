<html>
<head>
<title>Table-Oriented Programming (TOP)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Dosis:wght@200..800&family=Forum&family=Quattrocento:wght@400;700&family=Urbanist:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<base href="file:///home/wayland/src/TOP/TOP-doco/generated/">

<link rel="stylesheet" href="TOP.css"/>

</head>
<body>

<div class="wide-box">
<div class="navbar"><ul>
	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Table-Oriented Programming</a>
		<div class="dropdown-content">
			<a href="">Introduction to Table-Oriented Programming</a>
			<a href="Multi-Paradigm-Programming.html">Multi-Paradigm</a>
			<a href="Refactoring-Simplicity.html">Refactoring Simplicity</a>
		</div>
	</li>
	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Collection Convergence</a>
		<div class="dropdown-content">
			<a href="Concepts/Collection-Convergence/">Introduction to Collection Convergence</a>
			<a href="Concepts/Database-Engine-Neutrality.html">Database Engine Neutrality</a>
			<a href="Concepts/Memory-Mapping-Reduction.html">Memory-Mapping Reduction</a>
			<a href="Concepts/Data-Dictionaries.html">Data Dictionaries</a>
		</div>
	</li>
	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Language Support</a>
		<div class="dropdown-content">
			<a href="Concepts/Table-Friendly-Syntax.html">Table-Friendly Syntax</a>
			<!-- TODO: Split the above into tables, views, forms, and reports -->
		</div>
	</li>
	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Stylistic Features</a>
		<div class="dropdown-content">
			<a href="Concepts/Control-Tables/">Control Tables</a>
			<a href="#">Code Management</a>
		</div>
	</li>
	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Critiques</a>
		<!-- TODO: These should be me selecting the valid critiques from those he makes -->
		<div class="dropdown-content">
			<a href="#">OOP</a>
			<a href="#">SQL</a>
			<!-- TODO There should be others here -->
		</div>
	</li>
	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Other Material</a>
		<div class="dropdown-content">
			<a href="">Comparison of Raku TOP and xBase</a>
			<a href="">Eight Concepts</a>
			<section>
				<span class="dropdown-header">Implementation Features</span>
				<a href="#">File Directory Management</a>
			</section>
			<a href="">Why Table-Oriented Programming?</a>
			<a href="">Benefits of Good Table-Oriented Programming?</a>
			<a href="">Type Convergence</a>
			<a href="Merging-TOP-and-OOP.html">Merging TOP and OOP</a>
			<a href="Merging-Objections-Addressed.html" class="unimportant">Objections to Merging TOP and OOP addressed</a>
		</div>
	</li>
	
</ul></div>
</div>

<div class="main-box">


<div class="title">Refactoring Simplicity</div>

<p>One of the main goals of Table-Oriented Programming (TOP), much like any 
other code-organising paradigm (eg. OOP)  is to reduce the need for refactoring.  
TOP has some specific kinds of refactoring in mind that it wants to reduce.  
</p>

<p>When thinking about these things, it helps to have an example.  Many 
programmers who have organically built an application have had an experience 
where they started with an array of scalars, and then it turned into an array 
of associative arrays, and then realise it should be in an SQL database.  As our 
alternative, we should imagine that we started with a TOP table, instead of 
an array (because that's what we always do).</p>

<p>Back to the kinds of refactoring we want to reduce.  These are:</p>

<ul>
	<li><b>Collection Structure Change Refactoring:</b> when we need to change 
		the structure of our collection</li>
	<li><b>Collection Scaling Refactoring:</b> when we need to scale the 
		collection</li>
</ul>

<h1>Collection Structure Change Refactoring</h1>

<p>This is when we need to change the structure of our collection (often by 
adding new kinds of data our current taxonomy doesn't allow for); in our example 
above, instead of turning from an array to an array of associative arrays, we 
would just add more columns to our existing table.</p>

<div class="blockquote">

<a name="taxonomy"></a>
<h2> The Collection Taxonomy Trap </h2>

Although trees, for example, may sometimes work best with a different
collection interface,
it is conceivable that in the future the tree may
turn into a different structure, or non-tree operations
may be performed on a tree's nodes.
<p>
For instance, I often need to
find the largest or oldest file among several directories (folders)
under a file directory system.
These operations are non-tree operations on something that
is often viewed as a tree, perhaps mostly out of tradition. 
Further, there can/should be
more attributes upon which to sort, view, and organize files and folders;
perhaps even custom attributes. I have several folders
which have heavy HTML or web aspects to them. It would be
nice to do a query that asks for all folders marked
as having web content, regardless of their current
position in the folder tree. (UNIX-like utilities can
often do such, but have to re-index from scratch upon
each different query.)
<p>

This applies also to other collection "types" such as
<b>stacks, queues, hashes, sets</b>, etc. Often times the requirements
morph outside of the strict definition of these. Thus,
using a special interface for these that is not a subset
of a general collection protocol is too risky in my opinion.
It is even possible for the same data (node or record)
to need tree, stack,
and/or queue views <b>at the same time</b>. "Stack"
and "Queue" are what you <b>DO</b> to collections
(or how you see them), and <b>not what the
collections ARE</b>.
<p>
Thus, I am more inclined to consider these "special"
collection types as <b>views rather than a taxonomy</b> of
collection types. (See <a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/subtypes.htm">Subtype
Proliferation Myth</a> for more on subtyping issues.)
OO inheritance has resulted in excessive taxonomy-oriented
thinking among system designers in my opinion.
<p>
Note that it is fairly simple to make custom functions
to facilitate special views. For example, if you will
be doing a lot of stack operations, then build a
<b>Push(t, x)</b> and <b>Pop(t)</b> function, where "t" is the
table handle. This way you can get customized
views without locking yourself into a narrow
collection protocol or engine. Oracle has even
experimented with adding tree operations (for tables) to
it's SQL-based systems.

<a name="protect"></a>
<h3> Types for Access Enforcement?</h3>

Some have claimed that division into
collection sub-types makes for a form
of protection by keeping the programmer
from making "unauthorized" access.
The main problem I find with this is
that the collection types don't necessarily
correspond to access needs. I see nothing
in nature that makes access needs fit
collection sub-types (except perhaps
in narrow niches).
<p>
The common "can
add, can change, can delete, can view"
access breakdown can be given to all
"types". This makes it more general
then "can do stack operations but
not queue operations". For one, the
access administrator is not going to
know what those mean.
<p>
If you are talking programmer or code access
and not operator access, then the
standard add/change/delete/view
classification is still more general.
Plus, it creates red tape for the
programmer to keep asking for
permission to do non-stack operations
on what somebody thought would always
be a stack, for example. Predicting ahead of time
all access needs to a data set is nearly
impossible I find.

<p>
<div align="center">
<b>See Also:</b>
  <br><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/array1.htm">Array Problems</a>
  <br><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/trees.htm#flatten">How and Why to Rid Taxonomies in API's</a>
  <br><a href="Concepts/Collection-Convergence/">Collection Convergence</a>
  <br><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/table_qa.htm">Table Q &amp; A</a>
  <br><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/miscoop.htm#reinvent">Interface Bloat</a>
  <br><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/sets1.htm">File Directory Structures</a>
</div>

<div class="reference">
        <i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h1>Collection Scaling Refactoring</h1>

<p>The goal here is that, when your collection needs to scale, you just 
substitute a new backend, and barely change your code at all.  This is what 
<a href="Concepts/Database-Engine-Neutrality.html">Database Engine Neutrality</a> 
is all about.  In our example above, when we want to change from our structures 
in memory to using an SQL database, we just change the backend of the table, and 
carry on.  Need to switch to a replicating setup?  Just change backends again.  
Or maybe use the same one, but reconfigure it when it's initialised.  The only 
question is, who makes all these backends?  </p>



</div>

</body>
</html>
