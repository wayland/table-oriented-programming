
<html>
<head>
<title>Why Table-Oriented Programming? :: Table-Oriented Programming (TOP)</title>
<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Dosis:wght@200..800&family=Forum&family=Noto+Emoji:wght@300..700&family=Quattrocento:wght@400;700&family=Urbanist:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<!-- jQuery -->
<script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.slim.min.js">
</script>

<script type="text/javascript">
<!--
class	StackItem {
	Item = null;
	ParentList = null;

	constructor(item, parent, stack) {
		this.Item = item;
		this.ParentList = parent;
		stack.push(this);
	}
}

// If heading has an ID, make it anchor better
// Also, generate table of contents
$(document).ready(function() {
	// Start TOC code
	$("table-of-contents").empty();                                                            

	// jQuery stacks
	var HeadingStack = [];
	var prevHLevel = 0;

	var index = 0;                                                                    
	// End TOC code

	$("h1,h2,h3,h4,h5,h6").each(function(i) {
		var jQuery_Heading = $(this);
		var DOM_Heading = jQuery_Heading.get(0);

		//console.log('Starting: ' + jQuery_Heading.text());
		// if ($('#table-of-contents').is(':empty')){	console.log("Empty TOC-4!" + jQuery_Heading.text()); }

		// Create Anchor
		var anchor
		var anchor_name
		if(jQuery_Heading.attr('id')) {
			anchor_name = jQuery_Heading.attr("id");
		} else {
			anchor_name = DOM_Heading.nodeName + index;
		}
		var link_target = window.location.href + '#' + anchor_name;
		jQuery_Heading.before('<a name="' + anchor_name + '" class="pre-heading"/>');
		// End Create Anchor

		var originalText = jQuery_Heading.text();

		// Mark up named anchors
		if(jQuery_Heading.attr('id')) {
			jQuery_Heading.addClass('linkable');
			var headingId = jQuery_Heading.attr("id");
			jQuery_Heading.wrap('<a class="heading-link" href="' + link_target + '"></a>');
			var fontstring = "'Noto Emoji'";
			jQuery_Heading.append(' <span style="font-family: ' + fontstring + '">⚓</span>');
			jQuery_Heading.removeAttr("id");
		}
		// End Mark up named anchors

		// Start TOC code
		jQuery_Heading.before(anchor);                                     

		var	DOM_li = "<li><a href='" + link_target + "'>" + originalText + "</a></li>";
		var	jQuery_li = $(DOM_li);

		var thisHLevel = DOM_Heading.nodeName.substring(1,2);
		var thisHDiff = thisHLevel - prevHLevel;

		// console.log('t3==' + thisHDiff + '==' + thisHLevel + '==' + anchor_name);

		if(thisHDiff > 0) {
			for(let step = prevHLevel; step < thisHLevel; step++) {
				console.log('Starting step: ' + step);
				// Set up parent
				parent = HeadingStack[HeadingStack.length - 1];
				// Set up new stack item (including parent list) and push
				var isLast = step == (thisHLevel - 1);
				CurrentStackItem = new StackItem(
					isLast ? jQuery_li : null, 
					$('<ul foo="' + anchor_name + '-' + step + '"></ul>'),
					HeadingStack
				);
				if(isLast) {
					// Add item to list
					CurrentStackItem.ParentList.append(CurrentStackItem.Item);
				}
				// console.log(CurrentStackItem.ParentList.get(0));

				// Add list to list
				var useGrandParent = (typeof parent == 'undefined') ? "#table-of-contents" : parent.ParentList;
				// if(typeof useGrandParent == 'object') { console.log(useGrandParent.get(0)); }
				CurrentStackItem.ParentList.appendTo(useGrandParent);
			}
			// console.log(JSON.parse(JSON.stringify(HeadingStack)));
		} else if(thisHDiff == 0) {
			// Add to existing list
			CurrentStackItem.ParentList.append(jQuery_li);
		} else {
			for(let step = prevHLevel; step > thisHLevel; step--) {
				HeadingStack.pop();
			}
			parent = HeadingStack[HeadingStack.length - 1];
			parent.ParentList.append(jQuery_li);
		}
		prevHLevel = thisHLevel;
		index++;                                                    
		// End TOC code
	});
})

-->
</script>

<!-- Links and stylesheet -->
<base href="https://wayland.github.io/table-oriented-programming/TOP-doco/generated/">

<link rel="stylesheet" href="TOP.css"/>

</head>
<body>

<div class="wide-box">
<div class="navbar"><ul>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Progamming Productivity</a>
		<div class="dropdown-content">
			<a href="Programming-Productivity.html">Introduction to Programming Productivity</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">TOP</a>
		<div class="dropdown-content">
			<a href="Introduction/What.html">What is Table-Oriented Programming?</a>
			<a href="Introduction/Why.html">Why Table-Oriented Programming</a>
			<a href="Introduction/Terminology.html">Terminology</a>
			<a href="Introduction/History.html">History</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Collection Convergence</a>
		<div class="dropdown-content">
			<a href="Collection-Convergence/Introduction/">Introduction to Collection Convergence</a>
			<a href="Collection-Convergence/Tableish.html">role Tableish</a>
			<a href="Collection-Convergence/Database-Engine-Neutrality.html">Database Engine Neutrality</a>
			<a href="Collection-Convergence/Memory-Mapping-Reduction.html">Memory-Mapping Reduction</a>
			<a href="Collection-Convergence/Data-Dictionaries.html">Data Dictionaries</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Language Support</a>
		<div class="dropdown-content">
			<a href="Language-Support/Table-Friendly-Syntax.html">Table-Friendly Syntax</a>
			<a href="Language-Support/Table.html">class Table</a>
			<a href="Language-Support/View.html">class View</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Stylistic Features</a>
		<div class="dropdown-content">
			<a href="Stylistic-Features/Introduction.html">Introduction to TOP Style</a>
			<a href="Stylistic-Features/Control-Tables/">Control Tables</a>
			<a href="">Code Management</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Critiques</a>
		<div class="dropdown-content">
			<a href="">OOP</a>
			<a href="">SQL</a>
			<a href="">Trees</a>
			<a href="">Arrays</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Comparisons</a>
		<div class="dropdown-content">
			<a href="">Comparison of Raku TOP and xBase</a>
			<a href="Other-Items/Paradigm-Comparisons.html">Paradigm Comparisons</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">RAD</a>
		<div class="dropdown-content">
			<section>
				<span class="dropdown-header">Editors</span>
			<a href="RAD/Database-Design-Editor.html">Database Design Editor</a>
			<a href="RAD/Code-Editors.html">Code Editors</a>
			<a href="RAD/UI-Editors.html">UI editors (Forms &amp; Reports)</a>

			</section>
			<a href="RAD/Backend-to-Frontend-Design.html">Backend-to-Frontend Design</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Other Material</a>
		<div class="dropdown-content">
			<a href="Other-Items/Eight-Concepts.html">Eight Concepts</a>
			<section>
				<span class="dropdown-header">Implementation Features</span>
			<a href="">File Directory Management</a>

			</section>
			<a href="Other-Items/Why-Table-Oriented-Programming.html">Why Table-Oriented Programming?</a>
			<a href="Other-Items/Scalar-Type-Convergence.html">Scalar Type Convergence</a>
			<a href="Other-Items/Merging-TOP-and-OOP.html">Merging TOP and OOP</a>

		</div>
	</li>
	
</ul></div>
</div>

<div class="main-box">

<div class="title">Why Table-Oriented Programming?</div>

<div class="tagline">Tim Nelson, 2024</div>

<div id="table-of-contents"></div>

<div class="title">Why Table-Oriented Programming?</div>

<div class="tagline">Tim Nelson, 2024</div>

<p>I leave it to Tablizer/TOPMind to say this:</p>

<div class="blockquote">

Table-Oriented Programming (TOP for short) can be characterized
as a programming language and/or development method that makes
dealing with tables, lists, indexing, sorting, searching,
filtering, etc. a native and direct part of 
language design and complexity management.
This is a contrast to the clumsy collection API's and attribute
management techniques such as set/get
made popular by object oriented programming vendors.
Table-Oriented Programming can also be characterized by using tables to organize program logic, not just data. Such tables are called 
<a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/cntrl1.htm">Control Tables</a>.
They offer potential organization benefits over both raw
procedural programming and object oriented programming.
<p>
Most general-purpose languages use API-like constructs (function library calls) and SQL to deal with tables. We believe that this approach is too bulky, code intensive, and formal to be used often. Pushing into, Pulling out of, and converting data for API's and SQL is not very practical. (Some OOP languages do not call them API's but use something that is essentially the same.)
<p>
For example, most languages have special math-handling
syntax for dealing with mathematical equations. Example:
<pre>
   a = (b * c) + e + f
</pre>
Now, if your only choice was to use API's, then you
would have to use syntax like:
<pre>
   a = plus(plus(times(b,c),e),f)      // silly example
</pre>
Or, in OOP-ish syntax:
<pre>
   a = ((b.times(c)).plus(e)).plus(f)   // sillier
</pre>
Or, as an OOP purist:
<pre>
   a = ((b.math.times(c)).math.plus(e)).math.plus(f)   // silliest
</pre>

It would of course be silly to force math experts to use
such syntax; yet the <b>equivalent</b> is being done to database
and table developers.
This API-like approach is fine for occasional use, 
but if 70% of your
applications dealt with math, this would get a bit
cumbersome. We have  
<a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/funcs.htm">special constructs and syntax</a>
for math, <b>why not tables?</b> 
Most custom business applications use or need 
far more table handling than math. Perl is the king
of strings, Java is the king of networking, C is the
king of speed, we now need a king of tables. (SQL and
MS-Access fall short of the title).
<p>
The market focus on <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/oopbad.htm">Object Oriented Programming</a> has left table-handling in the dust with regard to innovation.  Sorted tables and lists are actually very useful for dealing with complex data structures including 
<a 
href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/trees.htm">trees</a>, 
stacks, queues, etc. Also, tables are not limited by the size of RAM, unlike traditional data structure algorithms. They provide built-in virtual memory. 
<p>
Most custom business applications are very table intensive. Accounting, inventory, reservation systems, order tracking, etc., are common examples. Also, file and directory lists, E-mail lists, sales prospects, and even lines and circles in a drawing program can be represented with tables. Yet, the languages usually used, such as C++ and Visual Basic, use nothing more than API's to work with tables. These languages 
encourage people to use in-memory constructs rather
than ordered tables. Sad.
<p>
<a name="sql"></a>
Although SQL is a high-level language that is quite powerful for certain types of operations, it is far from a general-purpose table processing language. Many programmers end up writing "speggitti-SQL" because the alternative is to use annoying API calls or convert to data cursors. SQL is also a poor match for interactive programs because it is more of a batch-processing and query processing language. 
<p>
SQL's set-oriented processing approach is often just not appropriate for many situations. SQL also has an annoying nest-happy LISP-like structure, which makes breaking down the logic into manageable chunks tough, especially for multi-joins. Using cursors can sometimes help, but they are far from standardized, given low vendor attention, and often not given "native" or direct access to the data engine.

<p>
SQL also cannot use functions and methods that are 
<u>in</u> the calling program; you have to use SQL's built-in or external functions. <u>SQL puts a wall between you, your code, and the data.</u> In addition, SQL does not support named fields sets, which will be described later.
(<a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/moretop.htm#sqlstuff">More on SQL and stored procedures.</a>)
<p>
TOP languages do exist in various levels or incarnations of
Table-orientedness. These include Xbase derivatives (dBASE, FoxPro, Clipper),
PAL (Paradox), Power-Builder, Perl (for certain list types), Progress,
Oracle's PL/SQL, and Clarion Developer.
(We will not necessarily vouch for the quality or design of
these languages, only say that they have a table-tilt to them.) 
These languages get little press compared to big OOP languages. Also, when upgrades are built for them, OOP features get most of the development resources, and their TOP features are treated as second priority by the vendors now. 
<p>
Why does OOP get 20 times more attention than TOP? We are not saying that TOP should be everything, but it does not deserve to be ignored. Being that tables are common and powerful, TOP does not deserve only 5% of the amount of attention that OOP gets. <u>We only ask for balance, not an overthrow.</u>
<p>

<hr>
<h2> My Motivation </h2>

Why am I so heck-bent on promoting Table-Oriented-Programming?
Simply because I have found the table paradigm so very
useful for RAD (rapid development), software organization, and
flexibility.
Yet the IT market focused on technologies like <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/oopbad.htm">
Object Oriented Programming</a> that made for better brochures
and airline magazine articles instead of real and practical
benefits. 
<p>
My exposure to TOP started back in the late 1980's when I
purchased a dBASE III book. I quickly fell in love with
dBASE and later its <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/xbasefan.htm">XBase</a> derivatives.
(dBASE was not the first language I learned, nor was it
the first that I used in a commercial setting.)
It made working with relational tables such a snap that
I started to view ALL collections as XBase tables.
(Collections are any set of similar or closely related items.)
This even began including <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/cntrl1.htm">program
logic</a>. (After all, OOP subclasses are simply a collection of
related classes.)
<p>
Other languages tended to use different
"containers" within the same language for collections.
Such containers include
arrays, vectors, dictionaries (associative arrays),
and API/object interfaces
to SQL database engines. The problem with these is that
they are very limited and very different from each
other. If the needs of a collection grew beyond the
bounds or features of one of these structures or significantly changed
in requirements, then switching to another
&quot;<a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/trees.htm#flatten">type</a>&quot;
of collection container or re-creating the needed
collection feature by hand was a pain in the [beep],
let alone darn illogical.
<p>
It seemed much more logical to me to have ONE
kind of interface into ANY collection and then
hook up an easy-to-use set of
<a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/collrght.htm">standard collection operations</a>
that would be available to ALL collections big and small.
(Not all engines will support all features, but the idea
is to switch engines to get needed features, and not your
existing API calls.)
Although it has some annoying limitations and language weaknesses,
XBase opened my eyes to table-oriented thinking.


<p>
OOP and other fads and trends prevented this powerful view
of collections from progressing any further, and even
reversed it to some extent. SQL as
an interface is fine for formal transactions, but is
too bulky and formal for many types of collection
manipulations. Thus, I am here trying to sell the dream and vision of
perhaps what should be called "collection-oriented-programming."
I found it a more powerful metaphore than anything else
on the market, and I hope you will too.
<p>

<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Tablizer/TOPMind, 1998-2002
</div>
</div>

<p>As an advocate of multi-paradigm programming, I may not agree with everything 
he says (eg. some of the pages he links to that bash OOP), but I fully agree 
with statements like "We only ask for balance, not an overthrow".  

<div class="blockquote">

<h2> Summary </h2>

The features listed here are only suggestions. The point is to generate the same type of thought process and analysis that triggered the development and popularity of OOP. Tables have been given the short end of the market attention stick. It is time for the pendulum to swing back, or at least to the center.
<p>
OOP has focused on the complexity of individual objects, but has generally neglected the relationships between <u>numerous similar objects</u>. When PC's took over many mainframe tasks, the complexity of the PC got all the attention. However, now the market is again focusing on the <u>relationship</u> between all these PC's. This is part of what made the Internet and intranets all the rage. A powerful, isolated PC was of limited use if it could not share and get data easily. In a similar vain, TOP is an attempt to look at the connectedness of objects again rather than just fat, powerful, but very isolated objects. OOP objects are at tad too lonely.
<p>

<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Tablizer/TOPMind, 1998-2002
</div>
</div>


</div>

<p/>

<div class="wide-box">
<div class="footer">
	<span class="left">			<a href="">&lt;&lt; Code Management</a>
</span>
	<span class="centre">-</span>
	<span class="right">			<a href="Other-Items/Scalar-Type-Convergence.html">Scalar Type Convergence &gt;&gt;</a>
</span>
</div>
<p/>
<div class="copyright">© Copyright Tim Nelson, 2024</div>
</div>
<p/>

</body>
</html>
