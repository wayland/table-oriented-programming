<html>
<head>
<title>Table-Oriented Programming (TOP)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Dosis:wght@200..800&family=Forum&family=Quattrocento:wght@400;700&family=Urbanist:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<base href="https://wayland.github.io/table-oriented-programming/TOP-doco/generated/">

<link rel="stylesheet" href="TOP.css"/>

</head>
<body>

<div class="wide-box">
<div class="navbar"><ul>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Introduction</a>
		<div class="dropdown-content">
			<a href="Introduction/What.html">What is Table-Oriented Programming?</a>
			<a href="Introduction/Why.html">Why Table-Oriented Programming</a>
			<a href="Introduction/Terminology.html">Terminology</a>
			<a href="Introduction/History.html">History</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Collection Convergence</a>
		<div class="dropdown-content">
			<a href="Collection-Convergence/Introduction/">Introduction to Collection Convergence</a>
			<a href="Collection-Convergence/Database-Engine-Neutrality.html">Database Engine Neutrality</a>
			<a href="Collection-Convergence/Memory-Mapping-Reduction.html">Memory-Mapping Reduction</a>
			<a href="Collection-Convergence/Data-Dictionaries.html">Data Dictionaries</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Language Support</a>
		<div class="dropdown-content">
			<a href="Language-Support/Table-Friendly-Syntax.html">Table-Friendly Syntax</a>
			<a href="">Tables</a>
			<a href="">Views</a>
			<a href="">Forms</a>
			<a href="">Reports</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Stylistic Features</a>
		<div class="dropdown-content">
			<a href="Stylistic-Features/Control-Tables/">Control Tables</a>
			<a href="">Code Management</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Critiques</a>
		<div class="dropdown-content">
			<a href="">OOP</a>
			<a href="">SQL</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Comparisons</a>
		<div class="dropdown-content">
			<a href="">Comparison of Raku TOP and xBase</a>
			<a href="Other-Items/Paradigm-Comparisons.html">Paradigm Comparisons</a>

		</div>
	</li>

	<li class="dropdown">
		<a href="javascript:void(0)" class="dropbtn">Other Material</a>
		<div class="dropdown-content">
			<a href="Other-Items/Eight-Concepts.html">Eight Concepts</a>
			<section>
				<span class="dropdown-header">Implementation Features</span>
			<a href="">File Directory Management</a>

			</section>
			<a href="">Why Table-Oriented Programming?</a>
			<a href="Other-Items/Benefits.html">Benefits of Good Table-Oriented Programming</a>
			<a href="">Type Convergence</a>
			<a href="Other-Items/Merging-TOP-and-OOP.html">Merging TOP and OOP</a>

		</div>
	</li>
foo	
</ul></div>
</div>

<div class="main-box">


<div class="title">Table-Friendly Syntax</div>

<h1>Overview</h1>

<p>Table-friendly syntax includes supporting tables and views as first-class 
citizens.  </p>

<p>The features on this page are drawn from a number of sources, including:</p>

<ul>
	<li>The <a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></li>
</ul>

<p>The main collection classes are:</p>
<ul>
	<li><b>Tablish:</b> Implements everything common to Tables and Views</li>
	<li><b>Table:</b> A set of named columns and unnamed rows; like an SQL 
		table, but with multiple backends</li>
	<li><b>View:</b> Like an SQL view</li>
</ul>

<h1>The Tableish</h1>

<p>The Tableish is a role that represents all features common to Tables and 
Views.  Features include:</p>

<h3>Transferring</h3>

<div class="blockquote">

This is the easy ability to transfer or copy information from one collection to
another. Note that filtering and sorting operations can be used to control the
order and subset of the collection(s) being moved. Either matching field/property
names are used to map one collection into another, and/or an explicit field/property
mapping is provided.

<div class="reference">
	<i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Field/Property Selection</h3>

<div class="blockquote">

Some operations may only need be done a subset of fields/properties.
For example, one may want to export only a subset of all the fields/properties
available in a collection.

<div class="reference">
	<i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Field Groups</h3>

<div class="blockquote">

One of the most time-wasting process in programming table processing with 
many of the popular languages is having to type the names of all the fields that 
will show up on a screen or report. It would be much easier to specify the name 
of a set, and all fields belonging to that set would then be used. Although sets 
could be pnumonic names, we chose to use letters in our example for 
simplicity.

<p>Suppose that we had to make a report that showed customer transaction detail, 
but which ommited customer names for reasons of confidentiality. With our setup, 
we could just ask for a report on all fields in set "B" (See the Groups column 
above).  When dealing with tables with 50 plus fields, specifying a set name is 
much simpler than typing 50 names or building a field loop.</p>

<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>


<h1>Tables</h1>

<h3> Definition of "Table" </h3>

<div class="blockquote">

I define a relational table as a collection of "rows".
Rows are basically dictionary structures with field names and
corresponding values. Rows have "potential" fields.
(I prefer "field" over "column" because column implies
fixed field widths, which is not a prerequisite for "table".)
"Potential field" means that a row does not have to actually
contain a given field or even a placeholder for it.
<p>
Potential fields are kept in a central list, meaning
that each row does not necessarily have to know of the
entire potential field list. If a request is made for a
field that is in the potential list, but that the row does
not actually contain, then a blank or empty value is returned.
(If a row contains a field name that is not in the central
list, that field it is not considered part of the table.)
<p>
Tables also potentially have multiple temporary and multiple
permanent indexes. Indexes allow one to find specific rows or
row sets without sequential traversal of the entire table.
<p>
Note that there is <b>no</b> necessary size or content
restriction on the fields. "Types" or length limits are
not a prerequisite. In fact, such restrictions can make
certain operations harder to implement. However, in practice,
such limits are often imposed on a product for performance reasons
or to fit a given standard, such as SQL.
<p>
Another way to identify or define "tables" is by their
<a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/collrght.htm">operations</a> rather than structure.

<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>


<h3>Miscellanous Table Features</h3>

<div class="blockquote">
<ul>
	<li>Because tables may come from many different sources, TOP should provide 
		a way to query to see which features are available. For example, there 
		should be a way to query a table source to see if the query limit 
		feature (FIX: described above) is available on a given table.</li>
	<li>ITOP should be able to generate temporary tables that automaticaly last 
		only as long as the program is running or until explicitly closed. These 
		tables should have a unique identity (automatically generated) to avoid 
		multi-user conflicts.</li>
	<li>Easy way to make a memory or temporary version or copy of a record, and 
		then be able to load this to and from a multi-record table when 
		needed.</li>
	<li>TOP should have the ability to evaluate internal-aware expression 
		strings, similar to the Perl EVAL() function (xbase uses "&amp;").  This 
		allows expressions with internal syntax and function calls (not just 
		SQL) to be stored in tables. This is a very powerful language feature. 
		Note that this is not the same as a general-purpose expression evaluator 
		because we often need a way to call <b>internal</b> functions. (A way to 
		test the validity of the expression should also be provided).</li>
</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h1>Views</h1>

<p>Features include:</p>

<h3>Filtering</h3>

<div class="blockquote">

This is the ability to view or access a collection through a filter.
Sometimes this is called a "view" (although views can involve
multiple tables or collections, see Joins below.)
It is generally analogous to using a "Where" clause in SQL.
Many of the operations below are to recognize any active
filter(s).

<div class="reference">
	<i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Multiple Virtual Orderings</h3>
<div class="blockquote">

Virtual Ordering is the ordering or
sorting of the collection. "Sorting" usually refers to
a permanent ordering, while "Indexing" refers to a temporary or virtual
sort. Virtual sorts are preferred for large or wide data-sets so that all
actual fields/attributes do not have to be physically moved. (Indexing essentially
uses pointers, but these pointers are not directly visible or accessible
to the programmer.)  

<p>There are usually temporary and permanent
indexes or their equivalent. Temporary indexes are only kept for the duration of 
a loaded application or a predetermined process. Permanent indexes
are kept for the life of a given table or collection that is kept
on disk or long-term storage. (Note that temporary indexes may
still use disk space, but it is assumed that they will be cleaned up
when no longer in use. Thus, they are not limited to RAM size.)

<p>Ideally, each element of the collection should be able to be extracted
or read in a specified order. This could be with a filter applied or the
entire collection.

<p>A given collection should be able to have
multiple virtual orderings, although
only one need be active (influencing) at a given time. The ordering
should be maintained even during data changes. Changing the data
should not require an explicit new Order command to restore virtual order
(unless explicitly overridden).

<div class="reference">
	<i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Searching</h3>
<div class="blockquote">

This is the ability to easily search through a collection to find a specific
row or instance. There are usually indexed searches and un-indexed 
searches. Indexed searches are faster, but require the generation of
an index first (if not already in place). 

<p>SQL generally combines searching with filtering using the Where
clause; however, for non-set-oriented processes, this is sometimes
not the most effective way to approach searching.

<div class="reference">
	<i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Grouping and Totalling</h3>
<div class="blockquote">

This is the ability to obtain summary information based on categories within
the collection or the entire collection. Typical examples include total
sales by region, average sales for the entire collection, etc. SQL usually
performs these using the  "Group By" clause or by aggregate operations
such as Avg(*), Sum(*), Count(*), and so forth. Averages, sums, and counts
can be obtained for sub-categories within the collection or on the entire
collection. 
<p>
For category grouping, usually a new collection is generated which contains
the summary information in a similar format to the original. For example,
thousands of sales records my be summarized into five (generated) records
where there is one record for each region (north, south, east, west, and central).


<div class="reference">
	<i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Joins</h3>
<div class="blockquote">

Some mechanism should be provided for the virtual joining
or relating of two or more collections so that they can be
treated as one collection using the standard operations listed
above. It is sometimes also called "look-up" or "cross-referencing".
Ideally "calculated joins" should be possible so that indexes
or link lists don't have to be manually created in advanced.
(Some operations may not be applicable or practical on virtual joined
collections. This is a controversial topic in the relational
world.)

<div class="reference">
	<i><a href="https://web.archive.org/web/20121111043922/http://www.geocities.com/tablizer/collrght.htm">
		Collection Bill of Rights</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p/>

<div class="blockquote">
<ul>
	<li>Ability to temporarily "join" several tables into one virtual table and 
		perform operations on it as if it were an actual table. Sometimes these 
		are called "views".  This provides similar functionality as inherited 
		properties in OOP.</li>
</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>


<h1>Built-in Forms</h1>

<div class="blockquote">
<ul>
<li>The acceptance of the scrolling screens of browsers should hopefully reduce 
the desire to jam as many fields on screen as possible. This will make it easier 
for the ITOP system to generate input screens based on the DD alone. Almost 
everything needed to generate such screens could come from the DD and the 
validation functions. graphic input screen builders should become a thing of the 
past.</li>

<li>Built-in, but optional, sort and search features for data grids. The user 
should be able to double-click on a column heading and chose to sort by or 
search on the field of that column.</li>

<li>Use of checkboxes, icons, etc. as representations of fields should be 
definable in the DD. Perhaps this can be done by having the post-validation 
function return a string with a special code for GUI components. For example, a 
checkbox might be specified with "@gui:checkbox value=on". An icon could be 
represented as such: "@gui:icon file='folder.gif'".</li>

</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>


<h1>Built-in Reports</h1>

<h1>Miscellaneous Implementation Features</h1>

<div class="blockquote">
<ul>
	<li><b>General</b></li>
	<ul>
	<li>Automatic control of data buffering during input and changes. The 
		programmer should be able to simply specify whether "optimistic" or 
		"pessimistic" record locking occurs, for example. He or she should not 
		have to create buffer variables and so forth.</li> 
	<li>A way to limit the upper size or time of a query result. Users 
		generating "runaway" queries is a common cause of performance 
		bottlenecks.</li>
	<li>Lists and array-like structures that can expand beyond memory space. 
		(The language automatically creates and handles temporary file buffering 
		if needed).  This is a contrast to constructs like Java VECTORs that 
		have a limit in size and quantity (related to memory constraints).</li> 
	</ul>
	<li><b>Data Dictionary</b></li>
	<ul>
	<li>Be able to create memory variables that take on characteristics of a 
		field as specified in the DD. In addition, fields should be "castable" 
		to other DD types if needed.</li>
	</ul>
	<li><b>Control Tables</b></li>
	<ul>
	<li>All <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/cntrl1.htm">
		control tables</a>, such as the DD's, should be 
		regular tables that can be processed just like any data table. 
		Encryption or some other technology can be used to protect such tables 
		from direct access by users if needed.</li>
	</ul>
</ul>
<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h1>Miscellaneous other features</h1>

<div class="blockquote">

<h4>Access Modes</h4>
<span style="color:red">TODO: What about cursors?</span>
Have 2 access modes: "direct" and "transactional". Direct access
mode allows one to access a field as if it was a memory variable,
and know that any changes will be written into the field. Transactional
mode is a bit more formal; you have to explicitly issue a Save
operation to save the record. Note that Direct Access mode may still
buffer actual writes to improve I/O, but the programmer need
not worry about this. Here is an example of each:
<pre>
   t = DBopen("tableA"  #<b>direct</b>)   // open table or view
   seek t #where name = 'Fred'
   if found(t) {
      t.name = 'Bob'    // change name from Fred to Bob
   }
   close t
   // '#' mark named parameters

Transactional:

   t = DBopen("tableA"  #<b>transact</b>)
   seek t #where name = 'Fred'
   if found(t) {
      t.name = 'Bob'
      if not save(t) {   // needed or no save is done
        // handle error
      }
   }
   close t     // (may not be necessary in some langs)
</pre>
The direct approach can be used if you know there will not
be resource conflict issues with other users or processes,
such as if you have exclusive access to the table. Note
that although this example can be easily done with SQL,
more interactive behavior would require more steps in SQL.
Example:
<pre>
   t = DBopen("tableA" #direct)   // open table or view
   seek t #where name = 'Fred'
   if found(t) {
      t.name = 'Bob'    // change name from Fred to Bob
   } else {
      display "Error, Fred not found."
   }
   close t 
</pre>
SQL would require one query to request the change, and another
to verify the change. Either that, one qurey to see if the
target is there, and another to change it.
<pre>
  s = "select from tableA where name = 'Fred' "
  t = DBopen(#sql s)
  if found(t) {
     s2 = "update tableA set name = 'Bob' "
     DBexecute  s2
  } else {
     display "Error, Fred not found."
  }
</pre>     

In this case it is not that much more code, but
in many situations it gets cluttered. Direct SQL makes it
tougher to mix reads and writes, usually requiring the issuing
of new queries. (Perhaps the direct approach could be
implemented via SQL underneath, but not something the
programmer has to concern him/herself with.)

<p>
Note that <tt>recCnt(t) &gt; 0</tt> could replace <tt>found(t)</tt>
where <tt>recCnt</tt> is short for "Record Count". This example
assumes there is only one Fred.

<div align="center">
See Also: <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/sqlcrit.htm">SQL Critique</a>
</div>

<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p/>

<div class="blockquote">

<h2> Related Information and Links </h2>
<ul>
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/whypr.htm">Why I prefer procedural/relational over OOP</a>
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/moretop.htm">More on T.O.P.</a> (including stored procedures)
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/cntrl1.htm">Control Tables</a>
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/oopbad.htm">OOP Criticism</a>
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/sqlcrit.htm">SQL Criticism</a> (boy, I sure like to criticize)
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/merge.htm">Merging TOP and OOP?</a>
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/prpats.htm">Table Patterns</a> (GOF meet TOP)
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/array1.htm">Array Criticisms</a>
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/table_qa.htm">Table Q &amp; A</a> 
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/buzzword.htm">Buzz-Words</a> (ITOP and OOP)
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/ddsamp.htm">Standard Collection Operations</a> (Collection Bill of Rights)
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/ddsamp.htm">More on Data Dictionaries and Table Browsers</a>
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/moretop.htm#setget">How Tables Simplify Interfaces</a> (Avoiding set/get's and other interface bloat)
<li> <a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/newlang.htm">ITOP Language Brainstorming Notes</a>
</ul>

<div class="reference">
        <i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>


</div>

<p/>



<div class="wide-box">
<div class="footer">
	<span class="left">			<a href="Collection-Convergence/Data-Dictionaries.html">&lt;&lt; Data Dictionaries</a>
</span>
	<span class="centre">-</span>
	<span class="right">			<a href="">Tables &gt;&gt;</a>
</span>
</div>
<div class="copyright">© Copyright Tim Nelson, 2024</div>
</div>


</body>
</html>
