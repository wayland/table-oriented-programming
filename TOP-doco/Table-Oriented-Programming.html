<html>
<head>
<title>Table-Oriented Programming (TOP)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Dosis:wght@200..800&family=Forum&family=Quattrocento:wght@400;700&family=Urbanist:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<link rel="stylesheet" href="TOP.css"/>
</head>
<body>

<div class="main-box">

<div class="title">Table-Oriented Programming (TOP)</div>

<div class="tagline">Tim Nelson, 2024</div>

<h1>Why Table-Oriented Programming?</h1>

<p>In short, most programming deals with tables at some point, and the 
approaches most other programming languages take to tables are fairly clunky, 
and this shows a way to improve that.  </p>

<p>Not convinced?  See <a href="Why-Table-Oriented-Programming.html">Why 
Table-Oriented Programming?</a></p>

<h1>Quick History</h1>

<p>Table-Oriented Programming was an as then unnamed paradigm that was popular in 
the 80s and 90s.  Common languages that used it were:</p>

<ul>
	<li>dBase</li>
	<li>Clipper</li>
	<li>Harbour/xHarbour (Open Source)</li>
	<li>Visual FoxPro/Microsoft FoxPro</li>
</ul>

<p>These languages had useful features that are not seen in modern programming 
languages.  </p>

<p>With the advent of the internet, and the popularity of Object-Oriented 
Programming, these languages fell out of use.  </p>

<p>In 1998-2002, as the table-oriented languages were falling out of use, "Findy 
Services and B. Jacobs" wrote a series of articles on "Table-Oriented Programming".  
These were, in their own words, unstructured and piecemeal.  These advocated for various 
features prevalent in these languages, and a few ideas of their own.  </p>

<h1>Overview</h1>

<p>This document is a rewrite of some parts of that documentation, in a more 
organised fashion.  </p>

<p>The eight primary TOP concepts have been grouped into the following 
categories:</p>

<ul>
	<li><b>Language Features:</b> These are features that a language needs 
	to support to enable TOP.  </li>
	<li><b>Implementation Features:</b> These are features that need 
	to be implemented, but tend to be in a backend somewhere, and, if done 
	right, are less visible to the user</li>
	<li><b>Stylistic Features:</b> Once the other features are in place, 
	these are stylistic idioms of TOP that enable you to make full use of 
	the power of the paradigm.  </li>
</ul>

<p>As part of the comparison, we will also be referencing:</p>

<ul>
	<li><b>SQL:</b> Table-oriented, but usually poorly-integrated into a 
	host language</li>
	<li><b>PL/SQL:</b> Table-oriented, but usually not as general-purpose as 
	could be desired.</li>
	<li><b>Raku: </b> Raku is a multi-paradigm language, sometimes touted as 
	omni-paradigm.  Despite this, it mostly doesn't support table-oriented 
	programming out-of-the-box.  However, its extreme flexibility will allow 
	table-oriented programming to be added.  Comments will be made 
	throughout these documents on how Raku relates to table-oriented 
	programming.</li>
</ul>


<h1>The Eight Primary Table-Oriented Programming Concepts</h1>

<h2>Language Features</h2>

<h3>Fundamental and Consistent Collection Operations</h3>

<div class="blockquote">
A base set of operations (interface) that all collections (tables, trees, 
stacks, lists, etc.) should have easy or built-in access to regardless of a 
collection's current size or complexity. (Arrays are evil! Arrays are the Goto 
of the collections world.)
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p>Raku has gone with the 
"everything-is-an-object" model prevalent in modern programming languages.  This 
is a good thing, as long as it is also acknowledged "most things are not 
<i>just</i> an object; Raku has been fairly good about this in most areas</p>

<p>What this means for TOP is that all collections are objects, and have fairly 
consistent interfaces (roles), including:</p>
<ul>
	<li>role <a href="https://docs.raku.org/type/Associative">Associative</a></li>
	<li>role <a href="https://docs.raku.org/type/Positional">Positional</a></li>
	<li>role <a href="https://docs.raku.org/type/Iterator">Iterator</a></li>
</ul>

<h3>Table-Friendly Syntax</h3>

<div class="blockquote">
Syntax and language constructs that make dealing with tables and T.O.P. 
easier and more natural. This includes overcoming the weaknesses of SQL. 
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p>Raku doesn't support this out of the box, but should be implementable using 
an appropriate set of classes</p>

<p>See <a href="Table-Friendly-Syntax-Data.html">Table Friendly Syntax - Data</a></p>

<h3>Database Engine Neutrality</h3>

<div class="blockquote">
A T.O.P. system should be able to access a wide variety of database engines.  
There are some practical limitations to this, but the goal should be kept in 
mind. 
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p>For Raku, this would be an implementation feature of the above-mentioned 
classes.  Also, this should be read as "backends" -- not all of them need be 
what we would call a "database engine" today.</p>

<h3>Data Dictionaries</h3>

<div class="blockquote">
Special Control Tables for storing processing, decision, and attribute logic 
for relational database fields and/or UI fields.
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p>When building the variety of backends mentioned above are built, one of the 
backends should be specifically for introspection of the tables.  Raku has a 
built-in introspection system (cf. the <a 
href="https://docs.raku.org/language/mop">Metaobject Protocol</a>).  We might be 
able to leverage this as well.  </p>

<p>See <a href="Data-Dictionaries.html">Data Dictionaries</a> for details</p>

<h3>Memory-Mapping Reduction</h3>

<div class="blockquote">
The goal of reducing or eliminating the need to manually map and/or transfer 
memory variables to and from table fields and to and from the UI (screens). 
(This process should be invisible to the programmer regardless of the fact that 
internal implementation usually uses memory-based copies.)
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p>Another feature that is invisible to the programmer, but saves lots of 
work.</p>

<p>Here it also becomes clear that TOP also requires UI support.  Raku again 
doesn't support this out-of-the-box.  Various UIs have been added, but these UIs 
don't have consistent interfaces (eg. a curses-based form can't be turned into a 
HTML form with minimal effort).</p>

<p>This would require another set of language features -- forms and reports</p>

<h3>File Directory Management</h3>

<div class="blockquote">
Hierarchies are too narrow in scope and too restrictive. It is time for 
multi-aspect thinking. One search key (the hierarchy) is not enough. [cf. 
<a href="https://web.archive.org/web/20120918011340/http://geocities.com/tablizer/sets1.htm">Alternatives to Trees</a>]
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>

</div>

<h2>Stylistic Features</h2>

<h3>Control Tables</h3>

<div class="blockquote">
A way of organizing processing, decision, and attribute logic.
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<h3>Code Management</h3>

<div class="blockquote">
Relational tables are a potentially much more sophisticated tool for managing 
complex and multi-faceted collections of programming code than OO classes or 
files.
<div class="reference">
	<i><a href="https://web.archive.org/web/20121024051826/http://www.geocities.com/tablizer/top.htm">Table-Oriented Programming</a></i>, Findy Services and B. Jacobs, 1998-2002
</div>
</div>

<p>Here, for the first time, I must partially disagree with Findy Services and 
B. Jacobs; this is because he is a pure TOP advocate, whereas I am an 
omni-paradigm advocate.  I would restate it as "Relational tables are in 
numerous instances a much more appropriate tool for managing complex and 
multi-faceted collections of programming code than OO classes or files".</p>

</div>

</body>
</html>
